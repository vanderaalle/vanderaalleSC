<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.44">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco CY}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco CY; min-height: 12.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco CY; color: #ad1d13}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco CY; color: #bf0000}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #653f2e; min-height: 12.0px}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ad1d13}
span.s1 {font: 12.0px Helvetica}
span.s2 {color: #23429c}
span.s3 {color: #0019ba}
span.s4 {color: #2b6f11}
span.s5 {font: 9.0px Monaco}
span.s6 {color: #000000}
span.s7 {color: #0000bf}
span.s8 {font: 9.0px Monaco CY}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>GeoGraphy: Structure</b></p>
<p class="p2"><br></p>
<p class="p3">The actual implementation tries to be as modular as possibile by making a large use of the dependency mechanism typical of Model-View-Controller architecture (see http://en.wikipedia.org/wiki/Publish/subscribe).</p>
<p class="p2"><br></p>
<p class="p3">What follows is a general introduction to structure. See the reference files for other infos. It is assumed that you evaluate the code as proposed in the text.</p>
<p class="p2"><br></p>
<p class="p4"><b>I. Sequencing</b><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p2"><br></p>
<p class="p3">The two main component classes are Graph and Runner.</p>
<p class="p5"><br></p>
<p class="p4"><b>Graph</b></p>
<p class="p3">It is devoted to handling all the data representing a graph.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">A graph is an IdentityDictionary following this format:</p>
<p class="p2"><br></p>
<p class="p6">{vID: [x, y, vDur, vLabel, vOpts, [end, eDur, eID, eOpts], ...etc], etc:...}</p>
<p class="p2"><br></p>
<p class="p3">where:</p>
<p class="p3">vID: <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ID of a vertex;<span class="Apple-converted-space"> </span></p>
<p class="p3">x, y: <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>its position</p>
<p class="p3">vDur: <span class="Apple-tab-span">	</span>a duration associated to the vertex</p>
<p class="p3">vLabel: <span class="Apple-tab-span">	</span>a label associated to the vertex</p>
<p class="p3">vOpts: <span class="Apple-tab-span">	</span>usable to store optional infos related to the vertex</p>
<p class="p3">[...]: <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>each following array represents an edge starting from the vertex<span class="Apple-converted-space"> </span></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>this means: n arrays --&gt; n edges from vID</p>
<p class="p2"><br></p>
<p class="p3">The format of an edge array is:</p>
<p class="p3">end: the end vertex<span class="Apple-converted-space"> </span></p>
<p class="p3">eDur: the duration of the edge</p>
<p class="p3">eID: an ID associated to the edge</p>
<p class="p3">eOpts: usable to store optional infos related to the edge</p>
<p class="p2"><br></p>
<p class="p3">A new, empty Graph is generated by:</p>
<p class="p2"><br></p>
<p class="p6">a = <span class="s2">Graph</span>.new ;</p>
<p class="p2"><br></p>
<p class="p3">See <b>Graph</b>.</p>
<p class="p2"><br></p>
<p class="p4"><b>Runner</b></p>
<p class="p3">Runner is the class which allows to control all the graph actants on a graph. As a consequence, the constructor requires a graph instance. The Runner is used to set a general tempo for all the actants (default = 60 bpm).</p>
<p class="p3">Actants are always instantianted through the Runner, so that it is possible to trace them.</p>
<p class="p2"><br></p>
<p class="p3">Consider this:</p>
<p class="p2"><br></p>
<p class="p7">b = <span class="s3">Runner</span>.new(a, name: <span class="s4">\Kobayashi</span>).gui <span class="s5">;</span></p>
<p class="p2"><br></p>
<p class="p3">The .gui message creates a GUI interface to the Runner b, which has the symbolic name "Kobayashi", just as an arbitraryy identifier. This interface will allows a graphical control of all the actants related to b. <span class="Apple-converted-space">  </span>You see a general control associate to the runner ("Kobayashi") and other slider labelled as free, as no actants have been instantiated through the Runner.</p>
<p class="p3">The interface is named "The Parallax View", as it deals with total control.</p>
<p class="p2"><br></p>
<p class="p3">See <b>Runner</b>.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p4"><b>II. (GUI) Control</b></p>
<p class="p2"><br></p>
<p class="p3">In order to control the process interactively two GUI elements are provided by the classes Painter and GraphParser.</p>
<p class="p2"><br></p>
<p class="p4"><b>Painter</b></p>
<p class="p2"><br></p>
<p class="p3">A Painter object is a GUI object providing a screen where the graph is painted and some related functionalities. Due to its nice semi transparent black fumé color it has gained the name "Grand Verre". When a vertex is created, you can drag it on the screen: its x and y properties will be updated consequently. This allows the user to clean a bit the topology of a graph<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p9"><span class="s6">o = </span><span class="s3">Painter</span><span class="s6">.new(a, b); <span class="Apple-tab-span">	</span></span>// paint a on a window<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">Painter requires a Graph, but also a Runner, because while sequencing in real time it paints in red each activated vertex. More, a primitive algorithm maps the frequency of passages on a vertex<span class="Apple-converted-space">  </span>to its color (--&gt; from blue it gets yellow): this can help in tracing paths on th graph. The colFact factor is a multiplier for the number of passages. Default value is 0.01, i.e. after 100 passages a vertex is<span class="Apple-converted-space">  </span>10*0.01 = 1, the lightest possibile.<span class="Apple-converted-space"> </span></p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p3">Note: there is also a<span class="Apple-converted-space">  </span><b>Grapher </b>class that uses Graphviz' automatic layout capabilities to plot the graph on a png. Useful in case of topological investigations. To be documented.</p>
<p class="p2"><br></p>
<p class="p4"><b>GraphParser</b></p>
<p class="p2"><br></p>
<p class="p3">The GraphParser defines some scripting commands in a micro language named iXno. Basically, this means writing strings representing simplified commands for manipulating Graph and Runner objects. These commands are parsed and translated into the opportune messages to Graph and Runner objects. It allows not to depend on pressing button but at the same time not to write SC code in order to control what's going on. Let's call it "live scripting". <span class="Apple-converted-space">  </span>In itself GraphParser is not related to GUI but you can pass the iXno commands from a GUI window.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="s6">p = </span><span class="s7">GraphParser</span><span class="s6">(a, b).gui ;<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// the parser and the gui</p>
<p class="p2"><br></p>
<p class="p3">GraphParser requires a Graph, a Runner and, in case it is needed, a Painter (which is not the cleanest thing).</p>
<p class="p3">It replies to the .gui message creating a gui panel.</p>
<p class="p3">The upper row contains a server control and a clock. Under the clock there is a tempo bar.</p>
<p class="p3">The bottom text field is a generic parser field, in the sense that<span class="Apple-converted-space">  </span>you can type SC code (to be evaluated by pressing ctrl + return) and also iXno code (to be evaluated by pressing ctrl + P, like "parsing").</p>
<p class="p2"><br></p>
<p class="p3">Each iXno command is in the form letter+ options.</p>
<p class="p3">E.g. you<span class="Apple-converted-space">  </span>can type sequence like this (or copy and paste, indeed):</p>
<p class="p2"><br></p>
<p class="p3">e+ s90 1 s92 1 s94 1 s95 1 s90 a+ s95</p>
<p class="p2"><br></p>
<p class="p3">and press ctrl + P.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p3">The sequence is made of two iXno commands, e+ and a+. More commands can be on the same line as the parser will separate them (hopefully...).</p>
<p class="p3">e+ says: create an edge between a series of vertices. If the vertices do not exist, they are created.</p>
<p class="p3">The form is vLabel eDur vLabel. The vID is automatically generated. It is better to work with labels, as they are much more meaningful, and they can be used to store sensible audio/music information.</p>
<p class="p3">a+ says: create a graph actant on a<span class="Apple-converted-space">  </span>vertex. The vertex can be specified by vID or vLabel (as here). As a consequence the Runner view is updated with a gui field providing some controls and infos related to the actant.</p>
<p class="p3">By pressing the buttons on the Parallax View the process starts.<span class="Apple-converted-space"> </span></p>
<p class="p3">With Kobayashi (i.e. the Runner button) you start all the actants, but you can choose to start each of them seprately. In thic case, ther is no difference.</p>
<p class="p3">You can set the weight of the actant by moving the slider.</p>
<p class="p3">On the Parser View (named "God bless Nim Chimpsky") you can change the tempo by moving the slider.</p>
<p class="p2"><br></p>
<p class="p3">Or by typing e.g :<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">t+ 480<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3">See <b>04.</b> <b>GeoGraphyGrammar</b>.</p>
<p class="p2"><br></p>
<p class="p4"><b>II. Audio</b></p>
<p class="p2"><br></p>
<p class="p3">Note that GeoGraphy is simply interested in sequencing aka composition.<span class="Apple-converted-space"> </span></p>
<p class="p3">So, it is pretty well finished here, from this point of view.</p>
<p class="p3">But evidently in order to make some noise it is necessary to connect some synth device to GeoGraphy.</p>
<p class="p3">The idea is to instantiate a class representing an audio device and to make it communicate with GeoGraphy. So, very simply, different classes can be used to represent audio processing. All these classes inherits from an abstract Class, GeoAudio, which provides opportunes dependency facilities, so that you do not have to get bored with them. But surely some better, faster and cleaner approach can be proposed.</p>
<p class="p11"><br></p>
<p class="p12"><br></p>
<p class="p13"><span class="s6">s = </span><span class="s3">Server</span><span class="s6">.local.boot ; </span>// or use the panel in NimChimpsky, or evaluate in the GraphParse win</p>
<p class="p13">// An available synth</p>
<p class="p6"><span class="s8">h = </span><span class="s3">Sinusoider</span>.new(b).initAudio ;</p>
<p class="p2"><br></p>
<p class="p3">(Now you can tweak with sliders)</p>
<p class="p2"><br></p>
<p class="p3">But see <b>03. GeoGraphyAudio</b>.</p>
<p class="p2"><br></p>
</body>
</html>
