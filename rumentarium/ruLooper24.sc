/*



*/

RuLooper24 {

	// a class for recording events 
	// events are generated by dataSender
	// the datasender is polled to the logger
	// the master is a ruMaster
	var <>dataSender, <>master ;
	// arrays with a sequence of events. Where events are written down
	var <>history, <>lastState ;
	// dur is how much you want to record in seconds
	// to be stored in into history
	// repeat is the number or repetitions
	// quant is a quantization for time
	// timeScale: experimental for timeScaling of interval
	var <>dur, <>repeat, <>quant, <>timeScale ;
	// if dur.isInf all the stuff is progressively recored
	var <>recTask, <>playTask ;
	// state flags
	var <>playOn, <>recOn ;
	var startTime, elapsedTime, previous ;
	var <>gui ;
	
	
	*new { arg dataSender, dur, repeat = inf, quant = 0.1, timeScale = 1  ; 
		^super.new.initRuLooper(dataSender,dur, repeat, quant, timeScale) 
	}

	initRuLooper { arg aDataSender, aDur, aRepeat, aQuant, aTimeScale ;
		dataSender = aDataSender ;
		//master = aMaster ;
		dur = aDur ;
		repeat = aRepeat ;
		quant = aQuant ;
		timeScale = aTimeScale ;
		// protect
		dur = dur.round(quant) ;
		history = [] ; 	
		lastState = [] ;
		playTask = Task({
			var ev ;
			var incrTime, port, value ;
			if (history[0].notNil) // protection against void history
			{
			repeat.do({ arg i ;
					previous = 0 ;
					history.do { |ev|
						# port, value, incrTime = ev ;
						((incrTime-previous)*timeScale).wait ; 
						// very lo-lev
						//master.setByID(port, value) ;
						this.changed(this, [\event].addAll(ev)) ;
						previous = incrTime ; 
					} ;
					((dur-incrTime)*timeScale).wait ;
					// sync message
					this.changed(this, [\sync]) ;
						})
			}
			}) ;	
		recTask = Task({
			var controlDataArr, oldArr = dataSender.internal ;
			while ( { elapsedTime <= dur }, {
					controlDataArr = Array.newFrom(dataSender.internal) ;
					controlDataArr.do({ arg val, ind ;
						if ( val != oldArr[ind] )
							{ this.recEvent(ind+1, val, elapsedTime.round(quant)) } 
					}) ;
					oldArr = Array.newFrom(dataSender.internal) ;
					quant.wait ;	
					elapsedTime = thisThread.seconds - startTime ;
				}) ;
		}) ;
		// global activity states	
		playOn = false ;
		recOn = false
	}
	
	// writes/reads to file
	writeHistory { arg pathname ; 
		history.writeArchive(pathname) ;
	}
	readHistory {  arg pathname ;
		history = Object.readArchive(pathname)
	}
	
	
	recEvent { arg port, value, elapsedTime ;
		// an event is a request for a value to a port
		var	event = [port, value, elapsedTime]  ;
		lastState = lastState.add(event) ;
	}				
	
	setDur { arg newDur ;
		dur = newDur ;
		this.changed(this, [\dur])
	}
	
	setQuant { arg newQuant ;
		quant = newQuant ;
		this.changed(this, [\quant])
	}

	setRepeat { arg newRepeat ;
		repeat = newRepeat ;
		this.stopPlay.play ;
		this.changed(this, [\repeat])
	}
	

	// Recording by polling
	rec { 
		
			startTime = thisThread.seconds ; // to be set by rec
			elapsedTime = 0 ;
			lastState = [] ; // clean the lastState when you start rec
			recTask.reset.play ;
		}

	stopRec {
		recTask.stop  
	}
					
	replaceHistory {
		history = Array.newFrom(lastState) ;
		this.changed(this, [\replaceHistory]) ;
	}				

	eraseHistory {
		history = [] ;
		// protecting
		fork { playTask.stop ; 0.1.wait ; playTask.play } ;
		this.changed(this, [\eraseHistory]) ;
	}				


	mergeHistory {
		var port, value, time ;
		var newHist = [], grid = [] ;  
		// create the grid as a 2D array
		24.do{ |i|
			grid = grid.add(Array.fill(dur/quant+1, nil)) 
		};
		// fill it and so overwrite positions
		history.do{|ev|
			# port, value, time = ev ;
			grid[port-1][time/quant] = ev ; 
		} ;
		lastState.do{|ev|
			# port, value, time = ev ;
			grid[port-1][time/quant] = ev ; 
		} ;
		// sort it
		// here we need flop
		// so that we have an array for each beat
		// and we simply take every.notNil event
		// from the seq
		history = Array.newFrom(grid.flop.flatten.select({|ev| ev.notNil})) ;
		this.changed(this, [\mergeHistory]) ;
	}				
					
	
	play {
			previous = 0 ; // to be set by play
			playTask.play ; 
			this.changed(this, [\play])
	} 
	
	resetPlay { playTask.reset } 
		
	stopPlay { 
			playTask.stop ;
			this.changed(this, [\stop])
	}
	
	makeGui { arg rate = 0.02 ;
		gui = RuLooperGUI24(this).fillWindow.drawRate_(rate).drawHistory ;
		this.addDependant(gui) ; 
	}
	
	
}



RuLooperGUI24 {
	
	var <>quant, <>looper, <>dur, <>history ;
	var <>wStep, <>hStep,<>numPix, <>offset ;
	var <>window, <>gridArr, <>valArr, <>defaults, <>barLine ;
	var new, old, oldVal ;
	var <>active ;
	var <>playTask, <>beat ;
	var <>drawRate  ;
	
	*new { arg looper, wStep = 15, hStep = 25, offset = 40 ;  
		^super.new.initRuLooperGUI(looper, wStep, hStep, offset) 
	}

	initRuLooperGUI { arg aLooper, aWStep, aHStep, anOffset ;
		looper = aLooper ;
		wStep = aWStep ;
		hStep = aHStep ;
		offset = anOffset ;
		dur = looper.dur ;
		quant = looper.quant ;
		history = looper.history ;
		drawRate = 0.02 ;
		window = Window.new("History loop", Rect(200, 200, 0,0)) ;
		beat = 0 ; // beat is for tracking visually the beat in playTask
		playTask = Task({
			inf.do({ 
				barLine.bounds_(barLine.bounds.left_(beat%numPix*wStep+offset, 0)) ;
				beat = beat + 1 ;
				quant.wait ;
			})
		})
	}

	fillWindow {
		numPix = ((dur/quant).asInteger) ;
		// clip to 800 px
		if ( wStep*numPix > 800 ) { wStep = 800/numPix.asInteger } ;
		window.bounds_(Rect(200, 200, numPix*wStep, 24*hStep)) ;
		24.do({ |i|
			StaticText.new(window, Rect(5, hStep*i, offset, hStep))
				.string_(i.asString++":")
				.font_(Font.new("Century Gothic", hStep-5))
				.stringColor_(Color.hsv(0.8, 0.8, 0.8))
		}) ;
		gridArr = [] ;
		valArr = [] ;
		defaults = [] ;
		24.do{ |i|
			valArr = valArr.add(Array.fill(numPix, 1)) ;
			gridArr = gridArr.add(
				Array.fill(numPix, { arg j;
					UserView.new(window, Rect(j*wStep+offset, i*hStep, wStep, hStep))
					}
				) 
			)
		} ;
		barLine = UserView.new(window, Rect(offset, 0, wStep, hStep*24))
			.background_(Color.red.alpha_(0.5)) ;
	}

	drawHistory {
		var port, value, totalTime ;
		var dur = looper.dur ;
		var col ;
		defaults = Array.fill(24, nil) ;	
		history = looper.history ;	
		// to clean up
		if (history.size == 0) { history = [[0,0,0]]} ;
		// trying to avoid cpu peaks
		fork{
		valArr.do{ arg seq, indSeq ;
			seq.do{ arg beat, indBeat ;
				history.do({ arg event ;
				 	if ([event[0]].add(event[2]) == [indSeq+1, indBeat*quant])
				 		{ defaults[indSeq] = 1-event[1] } ;
					valArr[indSeq][indBeat] = defaults[indSeq] ;
					})
			} ;
		} ;
		gridArr.do{ arg seq, indSeq ;
			seq.do{ arg beat, indBeat ;
				col = valArr[indSeq][indBeat] ;
				if (col.isNil) { col = valArr[indSeq].reverse[0] } ;
				if (col.isNil) { col = 1 } ;
				drawRate.wait ;
				beat.background_(Color.grey(col))
			}
		}} ;
		window.front ;
	}


	update { arg theChanged, theChanger, more ;
		var new ;
		case 
		/*
			{more[0] == \event }
					{
				more = more[1..].postln ;
				if (old.notNil) { 
					if (oldVal.isNil) { oldVal = 1 } ;
					old.background_(Color.grey(oldVal)) 
					} ;
				new = gridArr[more[0]-1][more[2]/quant] ;
				// protection against nil. Still not understood why...
				if (new.notNil){ 
					new.background_(Color.red) ;
					} ;
				oldVal = valArr[more[0]-1][more[2]/quant] ;
				old = new ;
			}
		*/
			{ [\replaceHistory, \mergeHistory, \eraseHistory].includes(more[0])}
				{
				this.drawHistory ; 
				old = nil ;
				oldVal = 1 ; // protection
				}
			{ more[0] == \sync }
				// reset bar 
				{ 	
				beat = 0 ; // resync to position
				barLine.bounds_(Rect(offset, 0, wStep, hStep*24)) 
				}
			{ more[0] == \play }
				{
				playTask.play ;
				}
			{ more[0] == \stop }
				{
				playTask.stop ;
				}
			{ more[0] == \dur }
				{
				dur = looper.dur ;
				window.view.removeAll ;
				this.fillWindow.drawHistory ;
				}
			{ more[0] == \quant }
				{
				quant = looper.quant ;
				window.view.removeAll ;
				this.fillWindow.drawHistory ;
				}
	} 


}