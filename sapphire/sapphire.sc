/*

This is the Sapphirology project

Classes for the computational, real-time, spatialized version of Enore Zaffiri's
Musica per un anno (1968).

*/


// Data Generator: sums up all Zaffiri's formalization
// see his explanation provided in the 1968 catalog

SapphireDataGenerator {

	var <>clockFreqArr, <>clockAmpArr ;
	var <>ampModes, <>freqModes, <>durations ;
	var <>days ;


	*new { ^super.new.initSapphireDataGenerator }

	initSapphireDataGenerator {
		var tot, add ;
		// create freq array
		clockFreqArr = Array.fill(6, {|i| 1968+(360*i)})++Array.fill(6, {|i| 1968-(360*i)}) ;
		// create amp array
		clockAmpArr = [] ; tot = -30 ; add = 10 ;
		12.do{
			clockAmpArr = clockAmpArr.add(tot);
			tot = tot+add ;
			if((tot == 0).or(tot == -30)) 	// the inversion mechanism: thresholds
				{ add = add.neg} ;		// inversion
		} ;
		freqModes = [
			[\f, \g, \f, \g, \f, \g, \f, \g, \f, \g, \f, \g, \f], // 1. dodecagon
			[\fC, \g, \f, \g, \f, \g, \f], 	// 2. exagon
			[\g, \f, \f, \g, \g], 			// 3. square
			[\f, \g, \f, \f], 				// 4. equilateral triangle
			[\g, \f, \g, \g],					// 5. isosceles triangle
			[nil] 								// 6. segment is void
		] ;
		ampModes = [
			[\C, \C, \SP, \C, \FP, \SP, \C, \C, \SP, \C, \FP, \SP, \C], // 1. dodecagon
			[\C, \C, \SP, \C, \FP, \SP, \C], 	// 2. exagon
			[\FP, \SP, \FP, \SP, \FP], 			// 3. square
			[\C, \FP, \SP, \C], 				// 4. equilateral triangle
			[\C, \FP, \SP, \C],					// 5. isosceles triangle
			[nil] 								// 6. segment is void
		] ;
		durations = [
			Array.fill(12, 5),
			Array.fill(6, 10),
			Array.fill(4, 15),
			Array.fill(3, 20),
			[25, 10, 25], // isosceles tr.
			[1, 60]		// segment
		]*60 ; // we convert minutes in seconds
		this.createDays ;
	}

	createDays {
		// days are generated by simply considering all possibile permutations as
		// as a number and sorting them
		var sequences = Array.fill(6.factorial, {|i| Array.series(6,1).permute(i)}) ;
		var items = [] ; // empty container
		var block, seq, sign ; // tools
		// here we assemble a string made of the number chars and convert it into int
		sequences.do{|seq| block = ""; seq.do{|i| block = block++i.asString } ;
			items = items.add(block.asInteger) } ;
		// sort on the resulting sequence of numbers
		items = items.sort ;
		// now building back a list
		sequences = [] ; // empty container
		// here we iterate on numbers and reconvert them into sequences
		items.do{|it, ind| seq = [] ; sign = if(ind.even){1}{1.neg} ;
			it.asString.do{|i| seq = seq.add(i.asString.asInteger*sign) } ;
				sequences = sequences.add(seq) } ;
		days = sequences.flat.clump(12) // we first flat and then re-group by 12
	}

	createDayProgram { arg day = 1, month = 1 ;
		// this creates the twelve layers to be used during the day
		var before = 0 ;
		var after = 12 ;
		var dayStr = [] ;
		// get the required day
		var dayPerm = days[(month-1)*30+(day-1)] ;
		// layers are twelve
		13.do{
			dayStr = dayStr.add(
			Array.fill(before, {nil})
			++dayPerm++
			Array.fill(after, {nil})	);
			before = before + 1 ;
			after = after - 1
			} ;
		// return the layer structure
		^dayStr
	}

	// private
	getHoursOfTheDay { arg dayProgram ; ^dayProgram.flop }
	// private
	getHourFromDay { arg hour, dayProgram ; ^this.getHoursOfTheDay(dayProgram)[hour-1] }

	// this is pretty general
	getHourSequence { arg hour, day, month ;
		var dayProgram = this.createDayProgram(day, month) ;
		^this.getHourFromDay(hour, dayProgram)
	}

	// private
	extractData { arg item, index ;
		var id = item.abs -1 ;
		var freqMode 	= freqModes[id] ;
		var ampMode 	= ampModes[id] ;
		var dur 	= durations[id] ;
		var seq, pitches, intensities ;
		var points ; // the sequence of points
		//points = Array.series(12,1).add(0).rotate(index.neg) ;
		points = Array.series(12).rotate(index.neg) ;
		points =
			case
		{ id == 0 } { points }
		{ id == 1 } { points.select{|p,i|  i%2 == 0 } }
		{ id == 2 } { points.select{|p,i|  i%3 == 0 } }
		{ id == 3 } { points.select{|p,i|  i%4 == 0 } }
		{ id == 4 } { points.select{|p,i|  [0,5,7,12].includes(i) } }
		{ id == 5 } { points.select{|p,i|  i%6 == 0 } } ;

		seq = clockFreqArr.rotate(index.neg)  ;
		pitches =
			case
		{ id == 0 } { seq }
		{ id == 1 } { seq.select{|p,i|  i%2 == 0 } }
		{ id == 2 } { seq.select{|p,i|  i%3 == 0 } }
		{ id == 3 } { seq.select{|p,i|  i%4 == 0 } }
		{ id == 4 } { seq.select{|p,i|  [0, 5,7,12].includes(i) } }
		{ id == 5 } { seq.select{|p,i|  i%6 == 0 } } ;
		pitches = pitches.add(pitches[0]) ;
		seq = clockAmpArr.rotate(index.neg)  ;
		intensities =
			case
		{ id == 0 } { seq }
		{ id == 1 } { seq.select{|p,i|  i%2 == 0 } }
		{ id == 2 } { seq.select{|p,i|  i%3 == 0 } }
		{ id == 3 } { seq.select{|p,i|  i%4 == 0 } }
		{ id == 4 } { seq.select{|p,i|  [0, 5,7,12].includes(i) } }
		{ id == 5 } { seq.select{|p,i|  i%6 == 0 } } ;
		intensities = intensities.add(intensities[0]) ;
		// checking sign
		if (item.sign == 1.neg)
			{ 	points =  [points[0]]++(points[1..].reverse) ;
				pitches = pitches.reverse;
				intensities = intensities.reverse ;
				freqMode = freqMode.reverse ;
				ampMode = ampMode.reverse ;
			} ;
		// final output
		^[freqMode, ampMode, points, dur, pitches, intensities]
	}

	generateHourData { arg hourSequence ;
		var data = [] ;
		hourSequence.do{|value, index|
			if (value.isNil.or( [6,6.neg].includes(value)))
				{data = data.add(nil)}
				{ data = data.add(this.extractData(value, index)) }
		} ;
		^data
	}

	// general
	generateHour { arg hour, day, month ;
		^this.generateHourData(this.getHourSequence(hour, day, month))
	}
}


/*

~sapphire = SapphireDataGenerator.new ;
~hourData = ~sapphire.generateHour(9, 9, 6) ;
*/



SapphireRunner {

	var <>synthArr ;
	var <>timeScale ;
	var <>dataGenerator ;
		// VBAP stuff
	var <>directions ; // an array containing speaker locations in degrees
	var <>speakerPositions ; // the same but in degree, external interface
	var <>dim ; // 2, ring, or 3, dome, see VBAP
	var <>vbapSpeakerArray ; // special array needed for vbap
	var <>vbapBuffer ; // the buffer required by VBAP
		// Controls: when set, are set to all sources
	var <spread ; // we can control the spread of all sources
	var <>outBus ;
	var <>date ;



	*new { arg timeScale = 1,
			dim  = 2, // over the plane
			// NOTE!!!! THIS IS OUTPUT BUS ORDER:
			// that is: you take each out and connect to related physical speaker
			/*

		0    1

		3    2

			*/
			// clockwise
			speakerPositions = [ pi.neg/4, pi/4, (3/4)*pi, (3/4)*pi.neg],
			spread = 0 ;
		^super.new.initSapphireRunner(timeScale, dim, speakerPositions, spread)
	}

	initSapphireRunner { arg aTimeScale, aDim, aSpeakerPositions, aSpread ;
		timeScale = aTimeScale ;
		dim = aDim ;
		// we put this here, because it's useless to do it for each source
		speakerPositions = aSpeakerPositions ;
		directions = speakerPositions.raddeg ; // VBAP wants degree
		// here we allocate a set of consecutive internal busses
		// where all the sources will write their n chans
		// a special array required by VBAP
		vbapSpeakerArray = VBAPSpeakerArray.new(dim, directions).postln ;
		spread = aSpread ;
		synthArr = [] ;
		// we keep SapphireDataGenerator internal because it cannot be modified
		dataGenerator = SapphireDataGenerator.new ;
		this.audioInit ;
	}


	audioInit {
		Server.default.waitForBoot{
			{
		SynthDef(\sapphireSynth, { arg out, // unrelevant, we pass a proxy
			freq = 1968, db = 0, // here we we map from control synths
			vol = 1, // vol is a general vol scaler in db
					// following params are for LFPulse
			pulseFreq = 0, pulseWidth = 1, which = 0,
			fade = 20,
					// following are inherited from VBAP ugen. We don't use elevation
			azimuth = 0, // here we map from control synth
			elevation = 0, spread = 0, vbapBuf ;
			var source = SinOsc.ar(freq, 0, db.dbamp*Line.kr(0,1, fade)) ;
			var ampMod =
				Select.kr(which,
					[1,
					// cut freq was 100
					FreeVerb.ar(LPF.ar(LFPulse.ar(Rand(0.15, 0.25), Rand(2pi), 0.01), 10), room:0.7),
					FreeVerb.ar(LPF.ar(LFPulse.ar(Rand(6,10), Rand(2pi), 0.5), 10), room:0.7)
					]
					) ;
			// we're hardcoding numChans, seems that it is the only way
			//Out.ar(out, VBAP.ar(4, source * ampMod * vol, vbapBuf, azimuth, elevation, spread));
			Out.ar(out, VBAP.ar(4, source * ampMod * vol, vbapBuf, azimuth, elevation, spread));
			//Out.ar(out, source * ampMod  * vol);
		}).add ;
		vbapBuffer = vbapSpeakerArray.loadToBuffer ;
		outBus = Bus.audio(Server.default, speakerPositions.size) ;
		// syncing to let server compile def
		Server.default.sync ;
		// creating synths
		12.do{ synthArr = synthArr.add(SapphireSynth(timeScale).set(\vbapBuf, vbapBuffer.bufnum).set(\out, outBus)) } ;
			}.fork
		}
	}

	setHour { arg hour, day, month ;
		var hourData = dataGenerator.generateHour(hour, day, month) ;
		var freqEnv, dbEnv, spatEnv, sustainEnv ;
		var freqMode, ampMode, dur, pitches, db, points ;
		date = [hour, day, month ] ;
		hourData = hourData[..hourData.size-2] ;
		hourData.do{ |hour, i|
			[hour, i].postln ;
			if (hour.notNil)
				{
			freqMode = hour[0] ; points = hour[2] ; dur = hour[3] ;
			ampMode = hour[1] ;
			pitches = hour[4] ; db = hour[5] ;
			freqEnv = this.createFreqEnv(freqMode, dur, pitches) ;
			dbEnv = this.createDbEnv(freqMode, dur, db) ;
			spatEnv = this.createSpatEnv(freqMode, points, dur) ;
			sustainEnv = this.createSustainEnv(ampMode, dur) ;
			synthArr[i].setEnvs([freqEnv, dbEnv, spatEnv, sustainEnv])
				}
		}
	}

	// envelopes creation

	createFreqEnv { arg freqMode, dur, pitches, type = \exp ;
		var n = pitches.size - 1 ;
		var k  = 0;
		var levels = []; var times = [] ;
		n.do{|i| levels = levels.add(pitches[i]) ;
			if (freqMode[i] == \g)
				{ levels = levels.add(pitches[i+1]) }
				{ levels = levels.add(pitches[i]) }
		};
		(n*2-1).do{|i| if (i%2 == 0) {times = times.add(dur[k]); k = k+1}
			{times = times.add(0)} } ;
		^Env(levels, times, curve:type) ;
	}


	createDbEnv { arg freqMode, dur, db, type = \lin ;
		var n = db.size - 1 ;
		var k  = 0;
		var levels = []; var times = [] ;
		dur.postln ;
		n.do{|i| levels = levels.add(db[i]) ;
			if (freqMode[i] == \g)
				{ levels = levels.add(db[i+1]) }
				{ levels = levels.add(db[i]) }
		};
		(n*2-1).do{|i| if (i%2 == 0) {times = times.add(dur[k]); k = k+1}
			{times = times.add(0)} } ;
		^Env(levels, times, curve:type) ;
	}


	createSpatEnv { arg freqMode, points, dur ;
		//  moves following freqMode
		var n = points.size-1 ;
		var p, k = 0 ;
		var step = 360/points.size ;
		var levels = []; var times = [] ;
		var degree = points.collect{|i| p = (360/12*i); if (p > 180) {p = (p-360) }{ p } } ;
		n.do{|i| levels = levels.add(degree[i]) ;
			if (freqMode[i] == \g)
				{ levels = levels.add(degree[i+1]) }
				{ levels = levels.add(degree[i]) }
		};
		(n*2-1).do{|i| if (i%2 == 0) {times = times.add(dur[k]); k = k+1}
			 {times = times.add(0)} } ;
		^Env(levels, times) ;
	}


	createSustainEnv { arg ampMode, dur ;
		var n = ampMode.size - 1 ;
		var levels = []; var times = [] ;
		var val, k = 0 ;
		n.do{|i|
			val = case
				{ ampMode[i] == \C} 	{ 0 }
				{ ampMode[i] == \SP} 	{ 1 }						{ ampMode[i] == \FP} 	{ 2 } ;
			levels = levels.addAll([val, val]) } ;
		(n*2-1).do{|i| if (i%2 == 0) {times = times.add(dur[k]); k = k+1}
			{times = times.add(0)} } ;
		^Env(levels, times) ;
	}

	setVol { arg vol ;
		 synthArr.do{|sy| sy.set(\vol, vol)}
		}

}

/*
s.reboot
~runner = SapphireRunner.new(10/60) ;
~runner.setHour(18, 28, 3)
//~runner.setHour(20,8,11)
(
~runner.synthArr.do{|sy,i|sy.createControlSynths} ;
~mix = {Out.ar(0, Mix(In.ar(~runner.outBus, 4)))}.play(addAction:\addToTail) ;

Chronometer.new
)
~runner.outBus.scope
~samp = Array.newClear(12) ;
j = {inf.do{
	~runner.synthArr.do{|sy,i| sy.ampBus.get{|val| ~samp[i] = val } };
	~samp.postln ;
	 1.wait ;
}}.fork
j.stop

GUI.swing

~runner.
s.scope
~runner.synthArr.do{|sy| sy.sustainBus.get.postln}
*/

SapphireSynth {

	var <>synth ; 					// the sine generator
		// the busses
	var <>freqBus, <>ampBus, <>spatBus, <>sustainBus ;
		// the envelopes
	var <>freqEnv, <>ampEnv, <>spatEnv, <>sustainEnv ;
		// the envelope generators
	var <>freqGen, <>ampGen, <>spatGen, <>sustainGen ;
	 	// so we can compress/expand times
	var <>timeScale ;

	*new { arg timeScale = 1; ^super.new.initSapphireSynth(timeScale) }

	initSapphireSynth { arg aTimeScale ;
		timeScale = aTimeScale ;
		freqBus = Bus.control(Server.default) ;
		ampBus = Bus.control(Server.default) ;
		spatBus = Bus.control(Server.default) ;
		sustainBus = Bus.control(Server.default) ;
		synth = Synth(\sapphireSynth) ;
		synth.map(\freq, freqBus) ;
		synth.map(\db, ampBus) ;
		synth.map(\azimuth, spatBus) ;
		synth.map(\which, sustainBus)
	}

	// we assume that the runner sends an EnvArr
	setEnvs { arg envArr ;
		freqEnv = envArr[0] ;
		ampEnv = envArr[1] ;
		spatEnv = envArr[2] ;
		sustainEnv = envArr[3] ;
	}

	set { arg anArg, aVal;
		this.synth.set(anArg, aVal) ;
	}

	run { arg flag = true;
		this.synth.run(flag) ;
	}

	// direct creation and playing
	// NOTE: this is the place where to scale up/down times
	createControlSynths {
		freqGen = { Out.kr(freqBus, EnvGen.kr(freqEnv, timeScale: timeScale, doneAction:2)) }.play; //.run(false)?
		ampGen = { Out.kr(ampBus, EnvGen.kr(ampEnv, timeScale: timeScale, doneAction:2)) }.play; //.run(false)?
		spatGen = { Out.kr(spatBus, EnvGen.kr(spatEnv, timeScale: timeScale, doneAction:2)) }.play; //.run(false)?
		sustainGen = { Out.kr(sustainBus, EnvGen.kr(sustainEnv, timeScale: timeScale, doneAction:2)) }.play; //.run(false)?

	}

}


SapphireMonitor {


	var <>runner ;
	var <>window, <>map ;
	var <>freqSlArr, <>spatSlArr, <>ampSlArr, <>sustainSlArr;
	var <>freqNArr, <>spatNArr, <>ampNArr, <>sustainNArr;
	var <>btArr ;
	var <>bck, <>stetho, <>stethoIdx ;
	var <>task, <>sampleTime ;
	var <>volK, <>volNb ;
	var positions ;
	var lGray, dGray, hues ;

	*new { arg runner, sampleTime = 0.5, stethoIdx = 0 ;
		^super.new.initSapphireMonitor(runner, sampleTime, stethoIdx) }

	initSapphireMonitor { arg aRunner, aSampleTime, aIdx ;
		var usr ;
		runner = aRunner ;
		sampleTime = aSampleTime ;
		stethoIdx = aIdx ;
		freqSlArr = [] ; spatSlArr = []; ampSlArr = [] ; sustainSlArr = [] ; btArr = [] ;
		// the basic Clock structure
		window = Window("The Sapphire Interface for Enore Zaffiri's Musica per un anno (1968)", Rect(100, 100, 1100, 900)).front ;
		window.view.background_(Color.gray(0.15));
		map = UserView(window, Rect(500, 0, 600, 600)) ;
		map.background_(Color.gray(0.15)) ;
		positions = Array.fill(12, {0}) ; // we use it to store positions and to redraw
		// colors
		hues = Array.fill(12, {|i| Color.hsv(i/13, i/24+0.4, 0.9)}) ;
		lGray = Color.gray(0.8) ; dGray = Color.gray(0.15) ;

		case
		{ GUI.id === \swing } {
			bck = CompositeView.new(window, Rect(10, 600, 500, 150)) ;
			stetho = Stethoscope.new(Server.local,4, stethoIdx, view: bck) ;
		//	window.onClose_{ stetho.free } ;
		//CmdPeriod.doOnce{ window.close } ;
		}
		{ GUI.id === \qt } {
			bck = CompositeView.new(window, Rect(10, 600, 475, 125)) ;
			// this is a pretty bizarre class
			// NEED TO BE REMOVED WHEN FEATURES ARE IMPLEMENTED
			stetho = 	QStethoscope2bis.new(Server.local,4,stethoIdx, view: bck,
			 audioColor: Color.red, controlColor:Color.green, background:Color.white) ;
			stetho.view.bounds_(Rect(0, 0, 450, 125))
		//	window.onClose_{ stetho.free } ;
		//CmdPeriod.doOnce{ window.close } ;
		} ;

		window.onClose_{ task.stop } ;
		StaticText(window, Rect(700, 600, 400, 100))
			.string_(
			"hour: "++runner.date[0].asString++", day: "++
				runner.date[1].asString++", month: "++runner.date[2].asString)
			.stringColor_(lGray).font_(Font("Futura", 20)) ;
		// vol
		volNb = NumberBox(window, Rect(550, 550, 50, 30)).value_(0) ;
		volK = Knob(window, Rect(500, 600, 120, 120))
			.value_(0)
			.font_(Font("Futura", 12))
			.action_{|me|
				var val =  me.value.linlin(0, 1, -96, 0) ;
				runner.synthArr.do
				{|sy| sy.set(\vol, val.dbamp );
				volNb.value_(val)
				}}
			.valueAction_(0.89)
			 ;

		this.getDrawFunc ;
		12.do{|i|
			StaticText(window, Rect(0, 500/12*(i+1)+10, 100, 500/12-20))
				.font_(Font("Futura", 14))
				.string_((i+1).asString).align_(\center)
				.background_(hues[i])  ;
			btArr = btArr.add(
				Button(window, Rect(10, 500/12*(i+1)+15, 20, 500/12-15))
				.font_(Font("Futura", 8))
				.states_([["on", lGray, Color.red, ],["off", Color.red, lGray]])
				.action_{|me| runner.synthArr[i].run([true, false][me.value])}
			) ;
			freqNArr = freqNArr.add(
				[UserView(window, Rect(100, 500/12*(i+1)+3, 100, 500/12-6))
					.background_(Color.red),
				StaticText(window, Rect(100, 500/12*(i+1)+10, 100, 500/12-20))
					.font_(Font("Futura", 8))
					.background_(lGray)
				]) ;
			ampNArr = ampNArr.add(
				[UserView(window, Rect(200, 500/12*(i+1)+3, 100, 500/12-6))
					.background_(Color.yellow),
				StaticText(window, Rect(200, 500/12*(i+1)+10, 100, 500/12-20))
					.font_(Font("Futura", 8))
					.background_(lGray)]) ;
			sustainNArr = sustainNArr.add(
			[UserView(window, Rect(300, 500/12*(i+1)+3, 100, 500/12-6))
				.background_(Color.green),
			StaticText(window, Rect(300, 500/12*(i+1)+10, 100, 500/12-20))
					.font_(Font("Futura", 8))
					.background_(Color.gray(0.8))]) ;
			spatNArr = spatNArr.add(
			[UserView(window, Rect(400, 500/12*(i+1)+3, 100, 500/12-6))
					.background_(Color.blue),
			StaticText(window, Rect(400, 500/12*(i+1)+10, 100, 500/12-20))
					.font_(Font("Futura", 8))
					.background_(lGray)]) ;
				} ;
		["synth", "freq", "db", "sustain", "spat"].do{|val, i|
			usr = [StaticText(window, Rect(i*100, 0, 100, 500/12))
				.string_(val)
				.stringColor_(lGray)
				.font_(Font("Futura", 12)),
			StaticText(window, Rect(i*100, 500/12+500, 100, 500/12))
				.string_(val)
				.stringColor_(lGray)
				.font_(Font("Futura", 12)) ];
			if (i == 0)
				{usr.do{|u| u.align_(\center)}}
				{usr.do{|u| u.align_(\left)}}
			} ;

	// now the task
		task = Task{ inf.do{
			var w, txt = ["", "continue", "slow pulse", "fast pulse"];
			var fr ;
			runner.synthArr.do{|sy,i|
				sy.freqBus.get{|val|
					{
					fr = val ;
					w = freqNArr[i][0].bounds ;
					w.width_(val.linlin(100, 4000, 0,100)) ;
					freqNArr[i][0].bounds_(w) ;
					freqNArr[i][1].string_(" "++val.round(0.01).asString)
					}.defer ;
							} ;
				sy.ampBus.get{|val|
					{
					val = if (fr != 0) {val}{inf.neg} ;
					w = ampNArr[i][0].bounds ;
					w.width_(val.linlin(-60, 10, 0, 100)) ;
					ampNArr[i][0].bounds_(w) ;
					ampNArr[i][1].string_(" "++val.round(0.01).asString)
					}.defer ;
							} ;
				sy.sustainBus.get{|val|
					{
					val = if (fr != 0) {val}{-1} ;
					w = sustainNArr[i][0].bounds ;
					w.width_(val.linlin(-1, 2, 0,100)) ;
					sustainNArr[i][0].bounds_(w) ;
					sustainNArr[i][1].string_(txt[val+1])
					}.defer ;
							} ;
				sy.spatBus.get{|val|
					{
					val = if (fr != 0) {val}{inf.neg} ;
					positions[i] = val ;
					w = spatNArr[i][0].bounds ;
					w.width_(val.linlin(-180, 180, 0,100)) ;
					spatNArr[i][0].bounds_(w) ;
					spatNArr[i][1].string_(" "++val.round(0.01).asString)
					}.defer ;
							} ;
				 } ;
			{map.refresh}.defer ;
	 		sampleTime.wait ;
		}} ;

	}


	getDrawFunc {
		map.drawFunc_{
			var point, point2, delta, center ;
			center = Polar(0,0.degrad).asPoint ;
			Pen.color_(Color.gray(0.8)) ;
			Pen.addArc(300@300, 200, 0, 2pi);
			Pen.stroke ;
			Pen.translate(300, 300) ;
			Pen.color_(lGray) ;
			Pen.font_(Font("Futura", 12)) ;
			12.do{|i|
				point = Polar(200, (360/12*i).degrad).asPoint ;
				Pen.color_(lGray) ;
				Pen.addArc(point, 5, 0, 2pi);
				Pen.fill ;
				Pen.color_(lGray) ;
				point2 = Polar(250, (360/12*i-90).degrad).asPoint.translate(-40@10.neg) ;
				Pen.stringAtPoint(runner.dataGenerator.clockFreqArr[i].asString++"Hz\n"++
				runner.dataGenerator.clockAmpArr[i].asString++"dB", point2) ;
				Pen.fill ;
				};
			Pen.color_(lGray) ;
			Pen.fill ;
			Pen.font_(Font("Futura", 10)) ;
			positions.do{|val, i|
				Pen.color_(hues[i]) ;
				point = Polar(200, (val-90).degrad).asPoint ;
				Pen.line(point, center) ;
				Pen.stroke ;
				Pen.addArc(point, 10, 0, 2pi);
				Pen.fill ;
				Pen.color_(dGray) ;
				delta = if (i>9) {5.neg}{4.neg} ;
				Pen.stringAtPoint((i+1).asString, point.translate(delta@6.neg)) ;
				Pen.fill ;
				}

			} ;


	}

}

/*

// at Conservatorio
// s.options.device = "MOTU 828mk2" ;


s.reboot ;
~runner = SapphireRunner.new(10/60) ;
~runner.setHour(18, 28, 3)
//~runner.setHour(13, 12, 9)

(
~runner.synthArr.do{|sy,i|sy.createControlSynths} ;
// stereo
// ~mix = {Out.ar([0,1], Mix(In.ar(~runner.outBus,4)))}.play(addAction:\addToTail) ;

// four chans excluding main outs
//~four = {Out.ar(2, In.ar(~runner.outBus,4))}.play(addAction:\addToTail) ;

// with main outs
~four = {Out.ar(0, EnvGen.kr(Env([0,1,1,0], [30, 600, 30]))
	*In.ar(~runner.outBus,4))}.play(addAction:\addToTail) ;

~monitor = SapphireMonitor(~runner) ; ~monitor.task.play ;

//~runner.setVol(-10.dbamp) ; // check me
Chronometer.new ;
)

~runner.outBus.scope




*/

/*

{Out.ar([0,1,2,3],WhiteNoise.ar)}.scope


x = {arg out = 0 ; Out.ar(out, WhiteNoise.ar)}.play


{inf.do{|i|
	{Out.ar(i%4, WhiteNoise.ar*EnvGen.kr(Env.perc, doneAction:2))
		}.play
	;1.wait}}.fork

*/
